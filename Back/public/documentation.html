<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <style>
      * {
        font-family: sans-serif;
      }
      pre {
        font-family: monospace;
        border: 1px solid black;
        background-color: #292828;
        padding: 10px;
        overflow-x: auto;
        border-radius: 10px;
        color: rgb(224, 97, 51);
        letter-spacing: 2px;
        font-size: 12px;
        line-height: 20px;
      }
      button {
        margin-top: 10px;
        padding: 5px 10px;
        background-color: #4caf50;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
      }
      button:hover {
        background-color: #77ad79;
      }
    </style>
    <script>
      function copiarCodigo() {
        var codigo = document.querySelector("pre code");
        var seleccion = window.getSelection();
        var rango = document.createRange();
        rango.selectNodeContents(codigo);
        seleccion.removeAllRanges();
        seleccion.addRange(rango);
        document.execCommand("copy");
        seleccion.removeAllRanges();
      }
    </script>
    <title>Documentation</title>
  </head>
  <body>
    <div style="display: flex">
      <ul
        style="width: 25%; list-style: none; position: fixed; top: 0; left: 0"
      >
        <h2>Documentacion de la API</h2>
        <li><a href="#introduction">Introducción</a></li>
        <li><a href="#bibliotecas">Bibliotecas</a></li>
        <li><a href="#instalacion">Instalación</a></li>
        <li><a href="#entorno">Variables de entorno</a></li>
        <li><a href="#folder">Estructura de carpetas</a></li>
        <li><a href="#jerarquia">Jerarquía</a></li>
        <li>
          <a href="#mongo">Configuración para la conexión a mongo atlas</a>
        </li>
        <li><a href="#mainconection">Archivo principal de la conexión</a></li>
        <li><a href="#router">Rutas y Controladores</a></li>
        <li><a href="#bd">Modelo de la base de datos</a></li>
        <li><a href="#middleware">middleware</a></li>
        <li><a href="#encriptar">Función para encriptar contraseña</a></li>
        <li><a href="#tokens">Función para generar tokens</a></li>
        <li><a href="#correos">Función para enviar correos</a></li>
      </ul>
      <div
        style="
          width: 60%;
          border-left: 1px solid gray;
          padding: 1%;
          margin-left: 35%;
        "
      >
        <section id="introduction">
          <h2>Introducción</h2>
          <p>
            El propósito de este documento es brindar una guía para instalar y
            configura la api rest en un entorno de desarrollo local.<br /><br />
            Se presenta información detallada acerca de la estructura del
            sistema, con el fin de llevar a cabo tareas como mantenimiento,
            instalación y exploración del API REST para el aplicativo web Red
            JODS Aliados, ofreciendo la información de cómo está organizado para
            que los desarrolladores que deseen contribuir al proyecto lo hagan
            de manera adecuada.<br /><br />
            El objetivo principal del proyecto es crear una plataforma web en la
            que los miembros de la organización faciliten la gestión y
            seguimiento de los Aliados, incluyendo información de contacto y
            actividades realizadas.<br /><br />
            <strong
              >En esta documentación mostraremos toda la explicación para el uso
              de la API REST del aplicativo web, siéntase libre luego de clonar
              el repositorio de editar este documento para agregar explicación
              de nuevas funcionalidades</strong
            >
          </p>
        </section>
        <section id="bibliotecas" style="border-top: 1px solid gray">
          <h2>Bibliotecas</h2>
          <h3>Express</h3>
          <p>
            Express es una librería de Node.js Proporciona los métodos y
            herramientas para manejar solicitudes HTTP, gestionar rutas,
            realizar operaciones CRUD en bases de datos y trabajar con
            diferentes tipos de middleware
          </p>
          <pre><code>npm install express</code></pre>
          <button onclick="copiarCodigo()">Copiar</button>

          <h3>Dotenv</h3>
          <p>
            Dotenv sirve para cargar las variables de entorno de la carpeta raiz
          </p>
          <pre><code>npm install dotenv</code></pre>
          <button onclick="copiarCodigo()">Copiar</button>

          <h3>Cors</h3>
          <p>
            Es una librería de Node.js que se utiliza para configurar
            encabezados CORS en una aplicación web o API
          </p>
          <pre><code>npm install cors</code></pre>
          <button onclick="copiarCodigo()">Copiar</button>

          <h3>Mongoose</h3>
          <p>
            Mongoose es una biblioteca de modelado de objetos MongoDB para
            Node.js que simplifica la interacción con una base de datos MongoDB
            a través de una API
          </p>
          <pre><code>npm install mongoose</code></pre>
          <button onclick="copiarCodigo()">Copiar</button>

          <h3>Bcryptjs</h3>
          <p>
            Bcrypt.js es una biblioteca de Node.js que se utiliza para cifrar
            contraseñas y datos sensibles mediante el algoritmo de hashing
            bcrypt.
          </p>
          <pre><code>npm install bcryptjs</code></pre>
          <button onclick="copiarCodigo()">Copiar</button>

          <h3>jsonwebtoken</h3>
          <p>
            Se utiliza para la creacion de tokens de accesos de usuarios a la
            api rest
          </p>
          <pre><code>npm install jsonwebtoken</code></pre>
          <button onclick="copiarCodigo()">Copiar</button>
        </section>
        <section id="instalacion" style="border-top: 1px solid gray">
          <h2>Instalacion</h2>
          <p>
            Se recomienda utilizar nodemon, utiliza el siguiente comando para
            instalarlo como dependencia de desarrollo
          </p>
          <pre><code>npm install nodemon --save-dev</code></pre>
          <button onclick="copiarCodigo()">Copiar</button>
          <p>Luego de clonar el repositorio desde el directorio</p>
          <pre><code>git clone  https://github.com/programateacademy/red-jods-aliados-backend.git </code></pre>
          <button onclick="copiarCodigo()">Copiar</button>
          <p>En el directorio que acabas de instalar ejecuta</p>
          <pre><code>cd Back//mueve a la carpeta principal
npm install //instala todas las dependencias </code></pre>
          <button onclick="copiarCodigo()">Copiar</button>
          <p>luego ya puedes correr el codigo</p>
          <pre><code>nodemon app //si instalaste nodemon
node app// sin nodemon
          </code></pre>
          <button onclick="copiarCodigo()">Copiar</button>
          <p>
            En consola debe salirte algo asi, donde se muestren todas las rutas
            de la api
          </p>
          <pre><code>[nodemon] starting `node app`
cargar ruta----------> auth
cargar ruta----------> doc
cargar ruta----------> nameroute
cargar ruta----------> recoverytoken
cargar ruta----------> userroute
api lista por el puerto 3000
***CONEXION CORRECTA***</code></pre>
        </section>
        <section id="entorno" style="border-top: 1px solid gray">
          <h2>Variables de entorno</h2>
          <p>
            Crea en la carpeta raiz un archivo .env para cargar todas las
            variables protegidas de la api en la carpeta que clonaste
            encontraras un archivo .env.example que contiene un ejemplo de todas
            las variables de entorno utilizadas en el aplicativo <br />Aca un
            ejemplo de lo que deberia ir en cada variable
          </p>
          <pre><code>
DB_URI=//enlace a la conexion de mongo
PORT=//puerto usado para pruebas el 3000
JWT_SECRET=//codigo secreto para generar los tokens
COREO_TEST=//correo de donde se enviaran todos los correos del aplicativo
PASS_CORREO=//credenciales si utilizas gmail se obtiene mediante permisos para app de terceros
          </code></pre>
        </section>
        <section id="folder" style="border-top: 1px solid gray">
          <h2>Estructura de carpetas</h2>
          <p>
            Al clonar el repositorio encuentras una carpeta llamada Back que
            contiene todo la api res <br />luego dos archivos
            <strong> .editorconfig </strong>es la Configuración del visual para
            el codigo y <strong> .gitignore </strong>para ignorar subida a git
            de la carpeta que contiene las dependencias <br />Dentro de Back se
            organiza de la siguiente manera:
          </p>
          <ul>
            <li>
              App:
              <ul>
                <li>Controllers: contiene los controladores de los endpoint</li>
                <li>
                  helpers: contiene funciones que ayudan con funcionalidades de
                  la api
                </li>
                <li>
                  middleware: contiene la verificacion de rutas mediante los
                  tokens
                </li>
                <li>routes: contiene la routas de la api rest</li>
                <li>
                  template: contiene los modelos html para los correos enviados
                  por la api
                </li>
              </ul>
            </li>
            <li>
              config: contiene la configuración para la conexion con mongo atlas
            </li>
            <li>
              public: contiene los documentos html de uso publico en la api
            </li>
          </ul>
        </section>
        <section id="jerarquia" style="border-top: 1px solid gray">
          <h2>Jerarquia</h2>
        </section>
        <section id="mongo" style="border-top: 1px solid gray">
          <h2>Configuración para la conexion con mongo atlas</h2>
          <pre><code>
const mongoose = require('mongoose');

mongoose.set('strictQuery', true);
const dbConnect = ()=>{
    const DB_URI = process.env.DB_URI //Se conecta a la url
    mongoose.connect(DB_URI, {
      useNewUrlParser: true,
      useUnifiedTopology: true
    }, (err, res)=>{
        if(!err){
          console.log('***CONEXION CORRECTA***')
        }else{
          console.log('***ERROR DE CONEXION***' + err)
        }
    })

}
module.exports = { dbConnect }
          </code></pre>
          <p>
            En primer lugar, se importa el módulo mongoose con la línea const
            mongoose = require('mongoose');. <br />
            <br />Luego, se configura mongoose para que sea estricto en la
            validación de consultas a la base de datos con la línea
            mongoose.set('strictQuery', true);.<br />
            <br />Después se define la función dbConnect, la cual se encarga de
            realizar la conexión a la base de datos. Esta función utiliza la URL
            de la base de datos que se obtiene de la variable de entorno DB_URI.
            La función mongoose.connect() se utiliza para conectarse a la base
            de datos y se especifican las opciones useNewUrlParser y
            useUnifiedTopology para evitar posibles errores de conexión.<br />
            <br />Finalmente, la función dbConnect es exportada para poder ser
            utilizada en otros archivos. <br />Es importante tener en cuenta que
            la conexión a la base de datos es asincrónica, por lo que se
            recomienda utilizar promesas o async/await para manejarla
            correctamente.
          </p>
        </section>
        <section id="mainconection" style="border-top: 1px solid gray">
          <h2>Archivo principal de la conexión</h2>
          <pre><code>
require('dotenv').config()//variables de entorno
const express = require('express')
const cors = require('cors')
const path =require('path')
const app = express()
const PORT = process.env.PORT || 3000 //puerto declarado en la variable de entorno
const { dbConnect } = require('./config/mongo') //requiere la conexion

app.use(cors())
app.use(express.json()) //permite envie de datos

app.use('/', require('./app/routes')) //ruta de la api

dbConnect()
app.listen(PORT, ()=>{ //Api escuchando
console.log('api lista por el puerto', PORT)
})
          </code></pre>
          <p>
            Primero, se importan los módulos dotenv, express, cors y path con
            las líneas require('dotenv').config(), const express =
            require('express'), const cors = require('cors') y const path
            =require('path') respectivamente. dotenv se utiliza para cargar las
            variables de entorno del archivo .env, express es el framework
            utilizado para crear la API, cors se utiliza para permitir
            peticiones desde distintos orígenes y path se utiliza para manejar
            rutas de archivos.<br />
            <br />Luego, se crea la instancia de express con la línea const app
            = express(). Se define el puerto en la variable PORT, el cual puede
            ser un valor definido en la variable de entorno process.env.PORT o
            3000 en caso de que no se haya definido.<br />
            <br />A continuación, se importa la función dbConnect del archivo
            ./config/mongo con la línea const { dbConnect } =
            require('./config/mongo'), la cual se encarga de conectar la API a
            la base de datos.<br />
            <br />Se utiliza app.use() para cargar los middlewares cors() y
            express.json(). cors() se utiliza para permitir peticiones desde
            distintos orígenes y express.json() para permitir el envío de datos
            en formato JSON.<br />
            <br />Luego, se utiliza app.use() para cargar las rutas de la API,
            que se encuentran en el archivo ./app/routes.<br />
            <br />Se realiza la conexión a la base de datos mediante la función
            dbConnect(). <br />
            <br />Por último, se inicia el servidor de la API con la función
            app.listen(), la cual recibe como argumento el número de puerto y
            una función de callback que se ejecuta cuando el servidor está listo
            para recibir peticiones.<br />
            <br />Este código utiliza Express para crear una API REST y
            conectarla a una base de datos MongoDB mediante mongoose. También
            utiliza middlewares como cors() y express.json() para permitir
            peticiones desde distintos orígenes y el envío de datos en formato
            JSON.
          </p>
        </section>
        <section id="router" style="border-top: 1px solid gray">
          <div>
            <h3>Rutas</h3>
            <h4>Ruta principal de la conexion</h4>
            <pre><code>
const express = require('express')
const router = express.Router()
const fs = require('fs') //lee el directorio donde se encuentra

const pathRouter = `${__dirname}`

const removeExtension = (fileName) =>{
  return fileName.split('.').shift()
}

fs.readdirSync(pathRouter).filter((file)=>{
  const fileWithOutExt = removeExtension(file)
  const skip = ['index'].includes(fileWithOutExt)
  if (!skip) {
    router.use(`/${fileWithOutExt}`, require(`./${fileWithOutExt}`))
    console.log('cargar ruta---------->',fileWithOutExt)
  }

})
            </code></pre>
            <p>
              En este archivo utilizamos el framework Express para crear un
              enrutador que maneja diferentes rutas. El código primero importa
              las dependencias necesarias, incluyendo Express y el módulo File
              System (fs) para leer el directorio donde se encuentra el archivo
              actual.<br />

              <br />La variable pathRouter almacena la ruta absoluta del
              directorio donde se encuentra el archivo actual mediante la
              constante __dirname.<br />

              <br />La función removeExtension es una función de ayuda que toma
              un nombre de archivo como entrada y devuelve el mismo nombre de
              archivo sin su extensión.<br />

              <br />La función readdirSync de la dependencia fs se utiliza para
              leer el directorio especificado por la ruta pathRouter y devuelve
              una lista de nombres de archivo en ese directorio. La función
              filter se utiliza para filtrar los nombres de archivo y omitir
              aquellos que tienen un nombre que coincide con la cadena
              'index'.<br />

              <br />Si el nombre de archivo no coincide con 'index', el código
              registra la ruta en el enrutador utilizando la función use de
              Express. Esta función agrega una función middleware que se activa
              cuando se accede a una ruta específica. En este caso, la función
              middleware se carga dinámicamente a partir del archivo que
              coincide con el nombre de archivo sin su extensión.<br />

              <br />Finalmente, el código muestra en la consola el mensaje
              'cargar ruta' seguido del nombre de archivo que se ha cargado.
              Esto ayuda a rastrear las rutas que se han cargado dinámicamente.
            </p>
            <p
              style="
                border: 1px solid #4caf50;
                background-color: #77ad79;
                border-radius: 10px;
                padding: 10px;
                color: white;
              "
            >
              <strong>Nota:</strong> Si deseas agregar nuevas rutas para nuevas
              funcionalidades de la api solo tienes que agrer otro archivo
              dentro de la carpeta routes con la configuración comun de rutas y
              otro controlador haciendo la api escalable para nuevos
              desarrolladores
            </p>
            <h4>Estructura de Rutas comunes del CRUD</h4>
            <pre><code>
const express = require('express') //importar express
const router = express.Router() //importando routes de express
const checkAuth = require('../middleware/auth')
const checkRoleAuth = require('../middleware/roleAuth')
const {getitems,getitem, newCharacter, editAlly, deleteAlly} = require('../controllers/namecontroller')

router.get('/',checkAuth,checkRoleAuth(['admin']), getitems)
router.get('/:id',checkAuth,checkRoleAuth(['admin']), getitem)
router.post('/',checkAuth,checkRoleAuth(['admin']), newCharacter)
router.put('/:id',checkAuth,checkRoleAuth(['admin']), editAlly)
router.delete('/:id', checkAuth,checkRoleAuth(['admin']), deleteAlly)

module.exports = router
            </code></pre>
            <p>
              El código importa la dependencia Express y crea un objeto
              enrutador utilizando la función Router de Express. También importa
              algunos middlewares (checkAuth y checkRoleAuth) y algunas
              funciones controladoras (getitems, getitem, newCharacter, editAlly
              y deleteAlly) que se encargan de manejar las solicitudes HTTP para
              diferentes rutas.<br />

              <br />Las rutas se definen utilizando los métodos HTTP get, post,
              put y delete que son accesibles a través del objeto enrutador.
              Cada ruta se define con una dirección URL que se corresponde con
              una función controladora que se ejecuta cuando se accede a esa
              ruta.<br />

              <br />Cada ruta también tiene uno o más middlewares (checkAuth y
              checkRoleAuth) que se ejecutan antes de la función controladora.
              Estos middlewares se encargan de autenticar y autorizar al usuario
              antes de permitirles acceder a la ruta.
            </p>
            <h4>Rutas personalizadas: Recuperar tokens para restablecer contraseña</h4>
            <p></p>
          </div>
          <div>
            <h3>Controladores</h3>
            <h4>Estructura de controladores comunes del CRUD</h4>
            <pre><code>
const { httpError } = require('../helpers/handleError')
const userModel = require('../models/user')

const getitems = async (req, res) =>{
  try {
    const listAll = await userModel.find({})
    res.send(listAll)
  } catch (e) {
    httpError(res,e)
  }
}

const getitem = async(req, res) =>{
  try {
    const itemId = req.params.id;
    const item = await userModel.findById(itemId);
    if (!item) {
      return res.status(404).send({ message: 'Item not found' });
    }
    res.send({ data: item });
  } catch (e) {
    httpError(res, e);
  }
}

const createitem = async (req, res) =>{
  try {
    const {name, username, email, pass, status, role} = req.body
    const resDetail = await userModel.create({
      name, username, email, pass, status, role
    })
    res.send({ data: resDetail})
  } catch (e) {
    httpError(res,e)
  }
}

const updateitem = async (req, res) =>{
  try {
    const itemId = req.params.id;
    const {name, username, email, pass, status, role} = req.body;
    const item = await userModel.findByIdAndUpdate(
      itemId,
      {name, username, email, pass, status, role},
      { new: true }
    );
    if (!item) {
      return res.status(404).send({ message: 'Item not found' });
    }
    res.send({ data: item });
  } catch (e) {
    httpError(res, e);
  }
}

const deleteitem = async (req, res) =>{
  try {
    const itemId = req.params.id;
    const item = await userModel.findByIdAndDelete(itemId);
    if (!item) {
      return res.status(404).send({ message: 'Item not found' });
    }
    res.send({ data: item });
  } catch (e) {
    httpError(res, e);
  }
}

module.exports= {getitem, getitems, createitem, updateitem, deleteitem}

            </code></pre>
            <p>Este es un código en Node.js que exporta varias funciones para manejar diferentes solicitudes HTTP relacionadas con la manipulación de datos de usuarios.<br>

              <br>Las funciones controladoras son getitems, getitem, createitem, updateitem y deleteitem. Cada una de ellas maneja una operación diferente en la base de datos de usuarios.<br>

              <br>La función getitems busca y devuelve todos los registros de usuario en la base de datos. La función getitem busca y devuelve un registro de usuario específico según el ID proporcionado. La función createitem crea un nuevo registro de usuario en la base de datos. La función updateitem actualiza un registro de usuario existente según el ID proporcionado. La función deleteitem elimina un registro de usuario existente según el ID proporcionado.<br>

              <br>Cada una de estas funciones utiliza una llamada asincrónica a la base de datos y devuelve una respuesta HTTP en función del resultado de la operación. Si la operación tiene éxito, devuelve un objeto de datos en la respuesta HTTP. Si hay un error, la función httpError maneja la respuesta de error para devolver una respuesta HTTP con el código de error y el mensaje de error correspondientes.</p>
            <h4>Controladores personalizados: Autentificación de usuarios</h4>
            <p></p>
            <h4>Controladores personalizados: Recuperación de contraseña</h4>
          </div>
        </section>
        <section id="bd" style="border-top: 1px solid gray">
          <h3>Modelo de la base de datos:</h3>
        </section>
        <section id="middleware" style="border-top: 1px solid gray">
          <h3>Middlewares</h3>
        </section>
        <section id="encriptar" style="border-top: 1px solid gray">
          <h3>Función para encriptar contraseña</h3>
          <pre><code>
const bcrypt = require('bcryptjs') //importar el encriptador
const encrypt = async (textPlain) => {
    const hash = await bcrypt.hash(textPlain, 10)
    return hash
}
const compare = async (passwordPlain, hashPassword) => {
    return await bcrypt.compare(passwordPlain, hashPassword)
}
module.exports = { encrypt, compare }
          </code></pre>
          <p>Este código importa una biblioteca llamada "bcryptjs" que proporciona funciones para encriptar y comparar contraseñas. Luego define dos funciones llamadas "encrypt" y "compare" que se exportan al final del archivo.<br>
<br>La función "encrypt" toma una cadena sin formato como entrada y devuelve una promesa que resuelve con una cadena encriptada. El segundo argumento de la función "bcrypt.hash" es el número de rondas de encriptación que se deben utilizar.<br>
<br>La función "compare" toma dos argumentos: una contraseña en texto plano y una contraseña encriptada. Devuelve una promesa que resuelve en verdadero si la contraseña en texto plano coincide con la contraseña encriptada. <button><a href="https://openbase.com/js/bcryptjs/documentation" target="_blank" style="text-decoration: none; color: white;">Documentacion de la biblioteca</a></button></p>
        </section>
        <section id="tokens" style="border-top: 1px solid gray">
          <h3>Funcion para generar tokens</h3>
        </section>
        <section id="correos" style="border-top: 1px solid gray">
          <h3>Funcion para enviar correos</h3>
        </section>
      </div>
    </div>
  </body>
</html>
